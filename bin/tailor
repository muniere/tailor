#!/usr/bin/env ruby

require 'ostruct'
require 'optparse'

TAILOR_DIR = File.expand_path('~/.tailor')
SSH_CONFIG = File.expand_path('~/.ssh/config')

options = OpenStruct.new({
  list: false
})

OptionParser
  .new("Usage: #{File.basename($0)} [options] [config]")
  .on('-l', '--list', 'List available environments') { |v| options.list = v }
  .parse!(ARGV)

#
# list envs
#
if options.list
  unless Dir.exists?(TAILOR_DIR)
    exit 0
  end

  STDOUT.puts Dir.entries(TAILOR_DIR).reject{ |e| e =~ /^\./ }.map{ |e| File.basename(e, '.*') }
  exit 0
end

#
# detect config path
#

if !(arg = ARGV.first).nil? and !File.extname(arg).empty?
  # file path
  cpath = File.join(Dir.pwd, arg)
elsif !arg.nil?
  # conf name
  cpath = File.join(TAILOR_DIR, arg + '.json')
else
  # default path
  cpath = File.join(TAILOR_DIR, 'default.json')
end

#
# read config
#
require 'colorize'
unless File.exists?(cpath)
  abort "[ERROR] File not found: #{cpath}".red
end

require 'json'
require 'recursive-open-struct'
begin
  config = JSON.parse(File.open(cpath).read).map{ |c| RecursiveOpenStruct.new(c) }
rescue => e
  abort e.inspect.red
end

#
# check config syntax
#
unless config.instance_of?(Array)
  abort '[ERROR] Config must be an array'
end

unless (invalids = config.select{ |conf| conf.host.nil? or conf.path.nil? }.map{ |conf| conf.to_h }).empty?
  abort [
    '[ERROR] Following config do not have required fields `host` and `path`',
    JSON.pretty_generate(invalids)
  ].join("\n").red
end

#
# tail logs
#
require 'net/ssh'
require 'parallel'
begin
  queue = Queue.new

  Thread.start do 
    while message = queue.pop
      if message.is_a?(Exception)
        STDERR.puts(message.inspect.red)
      elsif message.is_a?(String)
        STDOUT.puts(message)
      else 
        STDOUT.puts(message.inspect)
      end
    end
  end

  begin
    Parallel.each(config, in_threads: config.length) do |conf|
      ssh_conf = RecursiveOpenStruct.new(Net::SSH::Config.load(SSH_CONFIG, conf.host))
      color = (conf.options.label.color || 'default').to_sym
      chost = conf.host.colorize(color)

      Net::SSH.start(ssh_conf.host, ssh_conf.user, keys: ssh_conf.identityfile) do |ssh|
        ssh.open_channel do |channel|
          channel.on_data do |ch, data|
            data.lines.each do |line|
              queue.push("[#{chost}] #{line}")
            end
          end

          channel.exec("tailf #{conf.path}")
        end
      end
    end
  end
rescue Interrupt
  # do nothing
end
